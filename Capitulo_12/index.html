<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="index.css">
  <title>Renderizar um componente de classe para o DOM</title>
</head>

<body>
  <h1>Renderizar um componente de classe para o DOM</h1>

  Você talvez se lembre de usar a API do ReactDOM em um desafio anterior para renderizar elementos JSX para o DOM. O processo para renderizar componentes React ficará muito parecido. Os últimos desafios focaram em componentes e composição, então a renderização foi feita pra você nos bastidores. No entanto, nenhum código React que você escreva vai renderizar no DOM sem fazer uma chamada para a API do ReactDOM.

  Aqui está uma atualização na sintaxe: <code>ReactDOM.render(componentToRender, targetNode)</code>. O primeiro argumento é o componente React que você deseja renderizar. O segundo argumento é o nó do DOM onde você quer renderizar esse componente dentro.

  Componentes do React são passados a <code>ReactDOM.render()</code> um pouco diferente dos elementos JSX. Para elementos JSX, você passa o nome do elemento que deseja renderizar. No entanto, para componentes do React, você precisa usar a mesma sintaxe como se estivesse renderizando um componente aninhado, por exemplo <code>
    ReactDOM.render(
    &ltComponentToRender /&gt, targetNode)
  </code>. Você usa esta sintaxe para componentes de classe ES6 e componentes funcionais.

  Os componentes <code>Fruits</code> e <code>Vegetables</code> são definidos para você nos bastidores. Renderize ambos os componentes como filhos do componente <code>TypesOfFood</code> e, em seguida, renderize TypesOfFood para o DOM. Há um <code>div</code> com <code>id='challenge-node'</code> disponível para você usar.
</body>

</html>